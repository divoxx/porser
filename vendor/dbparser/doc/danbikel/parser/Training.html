<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_06) on Thu Nov 13 12:34:55 EST 2008 -->
<TITLE>
Training (Dan Bikel's Parsing Engine)
</TITLE>

<META NAME="date" CONTENT="2008-11-13">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Training (Dan Bikel's Parsing Engine)";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Training.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
Parsing Engine</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../danbikel/parser/TrainerEvent.html" title="interface in danbikel.parser"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../danbikel/parser/Transition.html" title="class in danbikel.parser"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?danbikel/parser/Training.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Training.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
danbikel.parser</FONT>
<BR>
Interface Training</H2>
<DL>
<DT><B>All Known Implementing Classes:</B> <DD><A HREF="../../danbikel/parser/lang/AbstractTraining.html" title="class in danbikel.parser.lang">AbstractTraining</A>, <A HREF="../../danbikel/parser/english/BrokenTraining.html" title="class in danbikel.parser.english">BrokenTraining</A>, <A HREF="../../danbikel/parser/chinese/NoNPBTraining.html" title="class in danbikel.parser.chinese">NoNPBTraining</A>, <A HREF="../../danbikel/parser/chinese/NPArgThreadTraining.html" title="class in danbikel.parser.chinese">NPArgThreadTraining</A>, <A HREF="../../danbikel/parser/english/NPArgThreadTraining.html" title="class in danbikel.parser.english">NPArgThreadTraining</A>, <A HREF="../../danbikel/parser/arabic/Training.html" title="class in danbikel.parser.arabic">Training</A>, <A HREF="../../danbikel/parser/chinese/Training.html" title="class in danbikel.parser.chinese">Training</A>, <A HREF="../../danbikel/parser/english/Training.html" title="class in danbikel.parser.english">Training</A></DD>
</DL>
<HR>
<DL>
<DT><PRE>public interface <B>Training</B></DL>
</PRE>

<P>
Specifies methods for language-specific preprocessing of training
 parse trees.  The primary method to be invoked from an implementation
 of this interface is <A HREF="../../danbikel/parser/Training.html#preProcess(danbikel.lisp.Sexp)"><CODE>preProcess(Sexp)</CODE></A>.  Additionally, as
 implementations are likely to contain or have access to appropriate
 preprocessing data and methods, this interface also specifies a crucial
 method to be used for post-processing, to &quot;undo&quot; what it was
 done during preprocessing after decoding.  This post-processing method is
 <A HREF="../../danbikel/parser/Training.html#postProcess(danbikel.lisp.Sexp)"><CODE>postProcess(Sexp)</CODE></A>, and is invoked by default by the
 <code>Decoder</code>.
 <p>
 A language package must include an implementation of this interface.
<P>

<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../danbikel/parser/Training.html#preProcess(danbikel.lisp.Sexp)"><CODE>preProcess(Sexp)</CODE></A>, 
<A HREF="../../danbikel/parser/Training.html#postProcess(danbikel.lisp.Sexp)"><CODE>postProcess(Sexp)</CODE></A>, 
<A HREF="../../danbikel/parser/Decoder.html" title="class in danbikel.parser"><CODE>Decoder</CODE></A></DL>
<HR>

<P>

<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../danbikel/parser/Training.html#addBaseNPs(danbikel.lisp.Sexp)">addBaseNPs</A></B>(<A HREF="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds and/or relabels base NPs in the specified tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../danbikel/parser/Training.html#addGapInformation(danbikel.lisp.Sexp)">addGapInformation</A></B>(<A HREF="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Augments nonterminals to include gap information for WHNP's that have
 moved and leave traces (gaps), as in the GPSG framework.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="http://java.sun.com/javase/6/docs/api/java/util/Set.html?is-external=true" title="class or interface in java.util">Set</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../danbikel/parser/Training.html#argNonterminals()">argNonterminals</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a static set of possible argument nonterminals.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../danbikel/parser/Training.html#defaultArgAugmentation()">defaultArgAugmentation</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The symbol that is used to mark argument (required) nonterminals by
 <A HREF="../../danbikel/parser/Training.html#identifyArguments(danbikel.lisp.Sexp)"><CODE>identifyArguments(Sexp)</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../danbikel/parser/Training.html#gapAugmentation()">gapAugmentation</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The symbol that will be used to identify nonterminals whose subtrees
 contain a gap (a trace).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../danbikel/parser/Training.html#getCanonicalArg(danbikel.lisp.Symbol)">getCanonicalArg</A></B>(<A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;argLabel)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the canonical version of the specified argument nonterminal,
 crucially including its argument augmentation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="http://java.sun.com/javase/6/docs/api/java/util/Set.html?is-external=true" title="class or interface in java.util">Set</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../danbikel/parser/Training.html#getPrunedPreterms()">getPrunedPreterms</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the set of pruned preterminals (<code>Sexp</code> objects).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="http://java.sun.com/javase/6/docs/api/java/util/Set.html?is-external=true" title="class or interface in java.util">Set</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../danbikel/parser/Training.html#getPrunedPunctuation()">getPrunedPunctuation</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the set of preterminals (<code>Sexp</code> objects) that were
 punctuation elements that were "raised away" because they were either at
 the beginning or end of a sentence.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../danbikel/parser/Training.html#hasGap(danbikel.lisp.Symbol)">hasGap</A></B>(<A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if and only if <code>label</code> has a
 gap augmentation as added by <A HREF="../../danbikel/parser/Training.html#addGapInformation(danbikel.lisp.Sexp)"><CODE>addGapInformation(Sexp)</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../danbikel/parser/Training.html#identifyArguments(danbikel.lisp.Sexp)">identifyArguments</A></B>(<A HREF="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Augments labels of nonterminals that are arguments.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../danbikel/parser/Training.html#isArgument(danbikel.lisp.Symbol)">isArgument</A></B>(<A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if and only if <code>label</code> has an
 argument augmentation as added by <A HREF="../../danbikel/parser/Training.html#identifyArguments(danbikel.lisp.Sexp)"><CODE>identifyArguments(Sexp)</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../danbikel/parser/Training.html#isArgumentFast(danbikel.lisp.Symbol)">isArgumentFast</A></B>(<A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if and only if the specified nonterminal
 label has an argument augmentation preceded by the canonical
 augmentaion delimiter.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../danbikel/parser/Training.html#isValidTree(danbikel.lisp.Sexp)">isValidTree</A></B>(<A HREF="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns whether the specified tree is valid.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../danbikel/parser/Training.html#postProcess(danbikel.lisp.Sexp)">postProcess</A></B>(<A HREF="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Post-processes a parse tree after decoding, eseentially undoing
 the steps performed in <A HREF="../../danbikel/parser/Training.html#preProcess(danbikel.lisp.Sexp)">preprocessing</A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../danbikel/parser/Training.html#preProcess(danbikel.lisp.Sexp)">preProcess</A></B>(<A HREF="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The method to call before counting events in a training parse tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../danbikel/parser/Training.html#preProcessTest(danbikel.lisp.SexpList, danbikel.lisp.SexpList, danbikel.lisp.SexpList)">preProcessTest</A></B>(<A HREF="../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</A>&nbsp;sentence,
               <A HREF="../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</A>&nbsp;originalWords,
               <A HREF="../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</A>&nbsp;tags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Preprocesses the specified test sentence and its coordinated list of tags.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../danbikel/parser/Training.html#prune(danbikel.lisp.Sexp)">prune</A></B>(<A HREF="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Prunes away subtrees that have a root that is an element of
 <code>nodesToPrune</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../danbikel/parser/Training.html#raisePunctuation(danbikel.lisp.Sexp)">raisePunctuation</A></B>(<A HREF="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Raises punctuation to the highest possible point in a parse tree,
 resulting in a tree where no punctuation is the first or last child of a
 non-leaf node.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../danbikel/parser/Training.html#relabelSubjectlessSentences(danbikel.lisp.Sexp)">relabelSubjectlessSentences</A></B>(<A HREF="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Relabels sentences that have no subjects with the nonterminal label
 returned by <A HREF="../../danbikel/parser/Treebank.html#subjectlessSentenceLabel()"><CODE>Treebank.subjectlessSentenceLabel()</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../danbikel/parser/Training.html#removeArgAugmentation(danbikel.lisp.Symbol)">removeArgAugmentation</A></B>(<A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removes any argument augmentations from the specified nonterminal label.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../danbikel/parser/Training.html#removeGapAugmentation(danbikel.lisp.Sexp)">removeGapAugmentation</A></B>(<A HREF="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;sexp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If the specified S-expression is a list, this method modifies the
 list to contain only symbols without gap augmentations;
 otherwise, this method removes the gap augmentation (if one exists)
 in the specified symbol and returns that new symbol.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../danbikel/parser/Training.html#removeNullElements(danbikel.lisp.Sexp)">removeNullElements</A></B>(<A HREF="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removes all null elements, that is, those nodes of <code>tree</code> for
 which <A HREF="../../danbikel/parser/Treebank.html#isNullElementPreterminal(danbikel.lisp.Sexp)"><CODE>Treebank.isNullElementPreterminal(Sexp)</CODE></A> returns
 <code>true</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../danbikel/parser/Training.html#removeWord(danbikel.lisp.Symbol, danbikel.lisp.Symbol, int, danbikel.lisp.SexpList, danbikel.lisp.SexpList, danbikel.lisp.SexpList, java.util.Set, java.util.Map)">removeWord</A></B>(<A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;word,
           <A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;tag,
           int&nbsp;idx,
           <A HREF="../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</A>&nbsp;sentence,
           <A HREF="../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</A>&nbsp;tags,
           <A HREF="../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</A>&nbsp;originalTags,
           <A HREF="http://java.sun.com/javase/6/docs/api/java/util/Set.html?is-external=true" title="class or interface in java.util">Set</A>&nbsp;prunedPretermsPosSet,
           <A HREF="http://java.sun.com/javase/6/docs/api/java/util/Map.html?is-external=true" title="class or interface in java.util">Map</A>&nbsp;prunedPretermsPosMap)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Invoked by the <A HREF="../../danbikel/parser/Decoder.html" title="class in danbikel.parser">decoder</A> as the first
 step in preprocessing (prior to the invocation of <A HREF="../../danbikel/parser/Training.html#preProcessTest(danbikel.lisp.SexpList, danbikel.lisp.SexpList, danbikel.lisp.SexpList)"><CODE>preProcessTest(danbikel.lisp.SexpList, danbikel.lisp.SexpList, danbikel.lisp.SexpList)</CODE></A>).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../danbikel/parser/Training.html#repairBaseNPs(danbikel.lisp.Sexp)">repairBaseNPs</A></B>(<A HREF="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Changes the specified tree so that when the last child of an
 NPB is an S, the S gets raised to be a sibling immediately following
 the NPB.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../danbikel/parser/Training.html#setUpFastArgMap(danbikel.parser.CountsTable)">setUpFastArgMap</A></B>(<A HREF="../../danbikel/parser/CountsTable.html" title="interface in danbikel.parser">CountsTable</A>&nbsp;nonterminals)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Indicates to set up a static map for quickly mapping argument nonterminals
 to their non-argument variants (that is, for quickly stripping away
 their argument augmentations).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="http://java.sun.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../danbikel/parser/Training.html#skip(danbikel.lisp.Sexp)">skip</A></B>(<A HREF="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns whether the specified tree is to be skipped when training.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../danbikel/parser/Training.html#startSym()">startSym</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the symbol to indicate hidden nonterminals that precede the first
 in a sequence of modifier nonterminals.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../danbikel/parser/Word.html" title="class in danbikel.parser">Word</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../danbikel/parser/Training.html#startWord()">startWord</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the <code>Word</code> object that represents the hidden "head
 word" of the start symbol.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../danbikel/parser/Training.html#stopSym()">stopSym</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the symbol to indicate a hidden nonterminal that follows the last
 in a sequence of modifier nonterminals.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../danbikel/parser/Word.html" title="class in danbikel.parser">Word</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../danbikel/parser/Training.html#stopWord()">stopWord</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the <code>Word</code> object that represents the hidden "head
 word" of the stop symbol.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../danbikel/parser/Training.html#stripAugmentations(danbikel.lisp.Sexp)">stripAugmentations</A></B>(<A HREF="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Strips any augmentations off all of the nonterminal labels of
 <code>tree</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../danbikel/parser/Training.html#topSym()">topSym</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the symbol to indicate the hidden root of all parse trees.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../danbikel/parser/Word.html" title="class in danbikel.parser">Word</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../danbikel/parser/Training.html#topWord()">topWord</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the <code>Word</code> object that represents the hidden "head
 word" of the hidden root of all parse trees.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../danbikel/parser/Training.html#traceTag()">traceTag</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The symbol that gets reassigned as the part of speech for null
 preterminals that represent traces that have undergone WH-movement, as
 relabeled by the default implementation of <A HREF="../../danbikel/parser/Training.html#addGapInformation(danbikel.lisp.Sexp)"><CODE>addGapInformation(Sexp)</CODE></A>.</TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="setUpFastArgMap(danbikel.parser.CountsTable)"><!-- --></A><H3>
setUpFastArgMap</H3>
<PRE>
void <B>setUpFastArgMap</B>(<A HREF="../../danbikel/parser/CountsTable.html" title="interface in danbikel.parser">CountsTable</A>&nbsp;nonterminals)</PRE>
<DL>
<DD>Indicates to set up a static map for quickly mapping argument nonterminals
 to their non-argument variants (that is, for quickly stripping away
 their argument augmentations).
 <p>
 <b>N.B.</b>: This method is necessarily thread-safe, as it is expected
 to be invoked by every <A HREF="../../danbikel/parser/Decoder.html" title="class in danbikel.parser"><CODE>Decoder</CODE></A> as it starts up, and since there
 can be multiple <A HREF="../../danbikel/parser/Decoder.html" title="class in danbikel.parser"><CODE>Decoder</CODE></A> instances within a given VM.
 <b><i>However</i></b>, note that it is <b>inappropriate to invoke this
 method</b> if the set of nonterminals in the specified counts table
 is incomplete (see the documentation for the <A HREF="../../danbikel/parser/SubcatBag.html" title="class in danbikel.parser"><CODE>SubcatBag</CODE></A> class
 for an instance where this will be the case).
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>nonterminals</CODE> - a counts table whose keys form a complete set of
 all possible nonterminal labels, as is obtained from
 <A HREF="../../danbikel/parser/DecoderServerRemote.html#nonterminals()"><CODE>DecoderServerRemote.nonterminals()</CODE></A> (the counts to which the
 nonterminals are mapped are not used by this method)</DL>
</DD>
</DL>
<HR>

<A NAME="preProcess(danbikel.lisp.Sexp)"><!-- --></A><H3>
preProcess</H3>
<PRE>
<A HREF="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A> <B>preProcess</B>(<A HREF="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</PRE>
<DL>
<DD>The method to call before counting events in a training parse tree.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>tree</CODE> - the parse tree to pre-process
<DT><B>Returns:</B><DD><code>tree</code> having been pre-processed</DL>
</DD>
</DL>
<HR>

<A NAME="removeWord(danbikel.lisp.Symbol, danbikel.lisp.Symbol, int, danbikel.lisp.SexpList, danbikel.lisp.SexpList, danbikel.lisp.SexpList, java.util.Set, java.util.Map)"><!-- --></A><H3>
removeWord</H3>
<PRE>
boolean <B>removeWord</B>(<A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;word,
                   <A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;tag,
                   int&nbsp;idx,
                   <A HREF="../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</A>&nbsp;sentence,
                   <A HREF="../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</A>&nbsp;tags,
                   <A HREF="../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</A>&nbsp;originalTags,
                   <A HREF="http://java.sun.com/javase/6/docs/api/java/util/Set.html?is-external=true" title="class or interface in java.util">Set</A>&nbsp;prunedPretermsPosSet,
                   <A HREF="http://java.sun.com/javase/6/docs/api/java/util/Map.html?is-external=true" title="class or interface in java.util">Map</A>&nbsp;prunedPretermsPosMap)</PRE>
<DL>
<DD>Invoked by the <A HREF="../../danbikel/parser/Decoder.html" title="class in danbikel.parser">decoder</A> as the first
 step in preprocessing (prior to the invocation of <A HREF="../../danbikel/parser/Training.html#preProcessTest(danbikel.lisp.SexpList, danbikel.lisp.SexpList, danbikel.lisp.SexpList)"><CODE>preProcessTest(danbikel.lisp.SexpList, danbikel.lisp.SexpList, danbikel.lisp.SexpList)</CODE></A>).
 Returns whether the specified word should be removed from the sentence
 before parsing.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>word</CODE> - a word in the sentence about to parsed<DD><CODE>tag</CODE> - the supplied part-of-speech tag of the specified word,
 or <tt>null</tt> if tags were not supplied<DD><CODE>idx</CODE> - the index of the specified word in the specified sentence<DD><CODE>sentence</CODE> - a list of <A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp"><CODE>Symbol</CODE></A> objects that represent the words
 of the sentence to be parsed<DD><CODE>tags</CODE> - coordinated list of supplied part-of-speech tag lists for each
 of the words in the specified sentence, or <tt>null</tt> if no tags
 were supplied<DD><CODE>originalTags</CODE> - the cached copy of the specified <tt>tags</tt> list,
 used when <A HREF="../../danbikel/parser/Settings.html#restorePrunedWords"><CODE>Settings.restorePrunedWords</CODE></A> is <tt>true</tt><DD><CODE>prunedPretermsPosSet</CODE> - the set of part-of-speech tags that were
 pruned during training<DD><CODE>prunedPretermsPosMap</CODE> - a map of words pruned during training to
 their part-of-speech tags when they were pruned
<DT><B>Returns:</B><DD>whether the specified word should be removed from the sentence
 before parsing</DL>
</DD>
</DL>
<HR>

<A NAME="preProcessTest(danbikel.lisp.SexpList, danbikel.lisp.SexpList, danbikel.lisp.SexpList)"><!-- --></A><H3>
preProcessTest</H3>
<PRE>
<A HREF="../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</A> <B>preProcessTest</B>(<A HREF="../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</A>&nbsp;sentence,
                        <A HREF="../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</A>&nbsp;originalWords,
                        <A HREF="../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</A>&nbsp;tags)</PRE>
<DL>
<DD>Preprocesses the specified test sentence and its coordinated list of tags.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sentence</CODE> - the list of words, where a known word is a symbol and
 an unknown word is represented by a 3-element list (see
 <A HREF="../../danbikel/parser/DecoderServerRemote.html#convertUnknownWords(danbikel.lisp.SexpList)"><CODE>DecoderServerRemote.convertUnknownWords(danbikel.lisp.SexpList)</CODE></A>)<DD><CODE>originalWords</CODE> - the list of unprocessed words (all symbols)<DD><CODE>tags</CODE> - the list of tag lists, where the list at index <i>i</i>
 is the list of possible parts of speech for the word at that index
<DT><B>Returns:</B><DD>a two-element list, containing two lists, the first of which
 is a processed version of <code>sentence</code> and the second of which
 is a processed version of <code>tags</code>; if <code>tags</code>
 is <code>null</code>, then the returned list will contain only
 one element (since <code>SexpList</code> objects are not designed
 to handle null elements)</DL>
</DD>
</DL>
<HR>

<A NAME="isValidTree(danbikel.lisp.Sexp)"><!-- --></A><H3>
isValidTree</H3>
<PRE>
boolean <B>isValidTree</B>(<A HREF="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</PRE>
<DL>
<DD>Returns whether the specified tree is valid.  The particular notion
 of validity can be language package-dependent.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>tree</CODE> - the parse tree to check for validity</DL>
</DD>
</DL>
<HR>

<A NAME="skip(danbikel.lisp.Sexp)"><!-- --></A><H3>
skip</H3>
<PRE>
<A HREF="http://java.sun.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A> <B>skip</B>(<A HREF="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</PRE>
<DL>
<DD>Returns whether the specified tree is to be skipped when training.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>tree</CODE> - an annotated training tree
<DT><B>Returns:</B><DD>a string if the specified tree is to be skipped
 when training, <code>null</code> otherwise<DT><B>See Also:</B><DD><A HREF="../../danbikel/parser/Trainer.html#train(danbikel.lisp.SexpTokenizer, boolean, boolean)"><CODE>Trainer.train(SexpTokenizer,boolean,boolean)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getPrunedPreterms()"><!-- --></A><H3>
getPrunedPreterms</H3>
<PRE>
<A HREF="http://java.sun.com/javase/6/docs/api/java/util/Set.html?is-external=true" title="class or interface in java.util">Set</A> <B>getPrunedPreterms</B>()</PRE>
<DL>
<DD>Returns the set of pruned preterminals (<code>Sexp</code> objects).
<P>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../danbikel/parser/Training.html#prune(danbikel.lisp.Sexp)"><CODE>prune(Sexp)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="prune(danbikel.lisp.Sexp)"><!-- --></A><H3>
prune</H3>
<PRE>
<A HREF="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A> <B>prune</B>(<A HREF="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</PRE>
<DL>
<DD>Prunes away subtrees that have a root that is an element of
 <code>nodesToPrune</code>.
 <p>
 <b>Side effect</b>: An internal set of pruned preterminals will
 be updated.  This set may be accessed via <A HREF="../../danbikel/parser/Training.html#getPrunedPreterms()"><CODE>getPrunedPreterms()</CODE></A>.
 <p>
 <b>Bugs</b>: Cannot prune away entire tree if the root label of the
 specified tree is in <code>nodesToPrune</code>.
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>tree</CODE> - the parse tree to prune
<DT><B>Returns:</B><DD><code>tree</code> having been pruned</DL>
</DD>
</DL>
<HR>

<A NAME="identifyArguments(danbikel.lisp.Sexp)"><!-- --></A><H3>
identifyArguments</H3>
<PRE>
<A HREF="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A> <B>identifyArguments</B>(<A HREF="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</PRE>
<DL>
<DD>Augments labels of nonterminals that are arguments.  This method is
 optional, and may be overridden to simply return <code>tree</code>
 untouched if argument identification is not desired for a particular
 language package.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>tree</CODE> - the parse tree to modify
<DT><B>Returns:</B><DD>a reference to the modified <code>tree</code> object<DT><B>See Also:</B><DD><A HREF="../../danbikel/parser/Treebank.html#canonicalAugDelimiter()"><CODE>Treebank.canonicalAugDelimiter()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="defaultArgAugmentation()"><!-- --></A><H3>
defaultArgAugmentation</H3>
<PRE>
<A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A> <B>defaultArgAugmentation</B>()</PRE>
<DL>
<DD>The symbol that is used to mark argument (required) nonterminals by
 <A HREF="../../danbikel/parser/Training.html#identifyArguments(danbikel.lisp.Sexp)"><CODE>identifyArguments(Sexp)</CODE></A>.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="isArgument(danbikel.lisp.Symbol)"><!-- --></A><H3>
isArgument</H3>
<PRE>
boolean <B>isArgument</B>(<A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label)</PRE>
<DL>
<DD>Returns <code>true</code> if and only if <code>label</code> has an
 argument augmentation as added by <A HREF="../../danbikel/parser/Training.html#identifyArguments(danbikel.lisp.Sexp)"><CODE>identifyArguments(Sexp)</CODE></A>.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="isArgumentFast(danbikel.lisp.Symbol)"><!-- --></A><H3>
isArgumentFast</H3>
<PRE>
boolean <B>isArgumentFast</B>(<A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label)</PRE>
<DL>
<DD>Returns <code>true</code> if and only if the specified nonterminal
 label has an argument augmentation preceded by the canonical
 augmentaion delimiter.  Unlike <A HREF="../../danbikel/parser/Training.html#isArgument(danbikel.lisp.Symbol)"><CODE>isArgument(Symbol)</CODE></A>, this
 method is thread-safe.  Also, it is more efficient than
 <A HREF="../../danbikel/parser/Training.html#isArgument(danbikel.lisp.Symbol)"><CODE>isArgument(Symbol)</CODE></A>, as it does not actually parse the
 specified nonterminal label.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getCanonicalArg(danbikel.lisp.Symbol)"><!-- --></A><H3>
getCanonicalArg</H3>
<PRE>
<A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A> <B>getCanonicalArg</B>(<A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;argLabel)</PRE>
<DL>
<DD>Returns the canonical version of the specified argument nonterminal,
 crucially including its argument augmentation.  For example,
 in the English Penn Treebank, the canonical version of <tt>NP-CLR-A</tt>
 would typically be <tt>NP-A</tt>, where <tt>A</tt> is the argument
 augmentation.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>argLabel</CODE> - the argument nonterminal to be canonicalized
<DT><B>Returns:</B><DD>the canonical version of the specified argument nonterminal</DL>
</DD>
</DL>
<HR>

<A NAME="addGapInformation(danbikel.lisp.Sexp)"><!-- --></A><H3>
addGapInformation</H3>
<PRE>
<A HREF="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A> <B>addGapInformation</B>(<A HREF="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</PRE>
<DL>
<DD>Augments nonterminals to include gap information for WHNP's that have
 moved and leave traces (gaps), as in the GPSG framework.  This method is
 optional, and may simply return <code>tree</code> untouched if gap
 information is desired for a particular language package.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>tree</CODE> - the parse tree to which to add gapping
<DT><B>Returns:</B><DD>the same <code>tree</code> that was passed in, with certain
 nodes modified to include gap information</DL>
</DD>
</DL>
<HR>

<A NAME="hasGap(danbikel.lisp.Symbol)"><!-- --></A><H3>
hasGap</H3>
<PRE>
boolean <B>hasGap</B>(<A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label)</PRE>
<DL>
<DD>Returns <code>true</code> if and only if <code>label</code> has a
 gap augmentation as added by <A HREF="../../danbikel/parser/Training.html#addGapInformation(danbikel.lisp.Sexp)"><CODE>addGapInformation(Sexp)</CODE></A>.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="gapAugmentation()"><!-- --></A><H3>
gapAugmentation</H3>
<PRE>
<A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A> <B>gapAugmentation</B>()</PRE>
<DL>
<DD>The symbol that will be used to identify nonterminals whose subtrees
 contain a gap (a trace).  This method is used by <A HREF="../../danbikel/parser/Training.html#stripAugmentations(danbikel.lisp.Sexp)"><CODE>stripAugmentations(Sexp)</CODE></A>, so that gap augmentations that are added by
 <A HREF="../../danbikel/parser/Training.html#addGapInformation(danbikel.lisp.Sexp)"><CODE>addGapInformation(Sexp)</CODE></A> do not get removed.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="traceTag()"><!-- --></A><H3>
traceTag</H3>
<PRE>
<A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A> <B>traceTag</B>()</PRE>
<DL>
<DD>The symbol that gets reassigned as the part of speech for null
 preterminals that represent traces that have undergone WH-movement, as
 relabeled by the default implementation of <A HREF="../../danbikel/parser/Training.html#addGapInformation(danbikel.lisp.Sexp)"><CODE>addGapInformation(Sexp)</CODE></A>.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="relabelSubjectlessSentences(danbikel.lisp.Sexp)"><!-- --></A><H3>
relabelSubjectlessSentences</H3>
<PRE>
<A HREF="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A> <B>relabelSubjectlessSentences</B>(<A HREF="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</PRE>
<DL>
<DD>Relabels sentences that have no subjects with the nonterminal label
 returned by <A HREF="../../danbikel/parser/Treebank.html#subjectlessSentenceLabel()"><CODE>Treebank.subjectlessSentenceLabel()</CODE></A>.  This method is
 optional, and may be overridden to simply return <code>tree</code>
 untouched if subjectless sentence relabeling is not desired for a
 particular language package.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>tree</CODE> - the parse tree in which to relabel subjectless sentences
<DT><B>Returns:</B><DD>the same <code>tree</code> that was passed in, with
 subjectless sentence nodes relabeled<DT><B>See Also:</B><DD><A HREF="../../danbikel/parser/Treebank.html#isSentence(danbikel.lisp.Symbol)"><CODE>Treebank.isSentence(Symbol)</CODE></A>, 
<A HREF="../../danbikel/parser/Treebank.html#subjectAugmentation()"><CODE>Treebank.subjectAugmentation()</CODE></A>, 
<A HREF="../../danbikel/parser/Treebank.html#isNullElementPreterminal(danbikel.lisp.Sexp)"><CODE>Treebank.isNullElementPreterminal(Sexp)</CODE></A>, 
<A HREF="../../danbikel/parser/Treebank.html#subjectlessSentenceLabel()"><CODE>Treebank.subjectlessSentenceLabel()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="stripAugmentations(danbikel.lisp.Sexp)"><!-- --></A><H3>
stripAugmentations</H3>
<PRE>
<A HREF="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A> <B>stripAugmentations</B>(<A HREF="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</PRE>
<DL>
<DD>Strips any augmentations off all of the nonterminal labels of
 <code>tree</code>.  The set of nonterminal labels does <i>not</i> include
 preterminals, which are typically parts of speech.  If a particular
 language's Treebank augments preterminals, this method should be
 overridden in a language package's subclass. The only augmentations that
 will not be removed are those that are added by <A HREF="../../danbikel/parser/Training.html#identifyArguments(danbikel.lisp.Sexp)"><CODE>identifyArguments(Sexp)</CODE></A>, so as to preserve the transformations of that
 method.  This method should only be called subsequent to the invocations
 of methods that require augmentations, such as <A HREF="../../danbikel/parser/Training.html#relabelSubjectlessSentences(danbikel.lisp.Sexp)"><CODE>relabelSubjectlessSentences(Sexp)</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>tree</CODE> - the tree all of the nonterminals of which are to be stripped
 of all augmentations except those added by <code>identifyArguments</code>
<DT><B>Returns:</B><DD>a reference to <code>tree</code></DL>
</DD>
</DL>
<HR>

<A NAME="raisePunctuation(danbikel.lisp.Sexp)"><!-- --></A><H3>
raisePunctuation</H3>
<PRE>
<A HREF="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A> <B>raisePunctuation</B>(<A HREF="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</PRE>
<DL>
<DD>Raises punctuation to the highest possible point in a parse tree,
 resulting in a tree where no punctuation is the first or last child of a
 non-leaf node.  One consequence is that all punctuation is removed from
 the beginning and end of the sentence.  The punctuation affected is
 defined by the implementation of the method <A HREF="../../danbikel/parser/Treebank.html#isPuncToRaise(danbikel.lisp.Sexp)"><CODE>Treebank.isPuncToRaise(Sexp)</CODE></A>.
 <p>
 <b>Side effect</b>: All preterminals removed from the beginning and end
 of the sentence are stored in an internal set, which can be accessed
 via <A HREF="../../danbikel/parser/Training.html#getPrunedPunctuation()"><CODE>getPrunedPunctuation()</CODE></A>.
 <p>
 Example of punctuation raising:
 <pre>
 (S (NP
      (NPB Pierre Vinken)
      (, ,)
      (ADJP 61 years old)
      (, ,))
    (VP joined (NP (NPB the board))) (. .))
 </pre>
 becomes
 <pre>
 (S (NP
      (NPB Pierre Vinken)
      (, ,)
      (ADJP 61 years old))
    (, ,)
    (VP joined (NP (NPB the board))))
 </pre>
 This method appropriately deals with the case of having multiple
 punctuation elements to be raised on the left or right side of the list of
 children for a nonterminal.  For example, in English, if this method
 were passed the tree
 <pre>
 (S
   (NP (DT The) (NN dog) (, ,) (NNP Barky) (. .) (. .) (. .))
   (VP (VB was) (ADJP (JJ stupid)))
   (. .) (. .) (. .))
 </pre>
 the result would be
 <pre>
 (S
   (NP (DT The) (NN dog) (, ,) (NNP Barky))
   (. .) (. .) (. .)
   (VP (VB was) (ADJP (JJ stupid))))
 </pre>
 <p>
 <b>Bugs</b>: In the pathological case where all the children of a node
 are punctuation to raise, this method simply emits a warning to
 <code>System.err</code> and does not attempt to raise them (which would
 cause an interior node to become a leaf).
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>tree</CODE> - the parse tree to destructively modify by raising punctuation
<DT><B>Returns:</B><DD>a reference to the modified <code>tree</code> object</DL>
</DD>
</DL>
<HR>

<A NAME="getPrunedPunctuation()"><!-- --></A><H3>
getPrunedPunctuation</H3>
<PRE>
<A HREF="http://java.sun.com/javase/6/docs/api/java/util/Set.html?is-external=true" title="class or interface in java.util">Set</A> <B>getPrunedPunctuation</B>()</PRE>
<DL>
<DD>Returns the set of preterminals (<code>Sexp</code> objects) that were
 punctuation elements that were "raised away" because they were either at
 the beginning or end of a sentence.
<P>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../danbikel/parser/Training.html#raisePunctuation(danbikel.lisp.Sexp)"><CODE>raisePunctuation(Sexp)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="addBaseNPs(danbikel.lisp.Sexp)"><!-- --></A><H3>
addBaseNPs</H3>
<PRE>
<A HREF="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A> <B>addBaseNPs</B>(<A HREF="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</PRE>
<DL>
<DD>Adds and/or relabels base NPs in the specified tree.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>tree</CODE> - the parse tree in which to add and/or relabel base NPs
<DT><B>Returns:</B><DD>a reference to the modified version of <code>tree</code><DT><B>See Also:</B><DD><A HREF="../../danbikel/parser/Treebank.html#isNP(danbikel.lisp.Symbol)"><CODE>Treebank.isNP(Symbol)</CODE></A>, 
<A HREF="../../danbikel/parser/Treebank.html#baseNPLabel()"><CODE>Treebank.baseNPLabel()</CODE></A>, 
<A HREF="../../danbikel/parser/Treebank.html#NPLabel()"><CODE>Treebank.NPLabel()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="repairBaseNPs(danbikel.lisp.Sexp)"><!-- --></A><H3>
repairBaseNPs</H3>
<PRE>
<A HREF="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A> <B>repairBaseNPs</B>(<A HREF="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</PRE>
<DL>
<DD>Changes the specified tree so that when the last child of an
 NPB is an S, the S gets raised to be a sibling immediately following
 the NPB.  That is, situations such as
 <pre>
 (NP
   (NPB
     (DT an)
     (NN effort)
     (S ...)))
 </pre>
 get transformed to
 <pre>
 (NP
   (NPB
     (DT an)
     (NN effort))
   (S ...))
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="removeNullElements(danbikel.lisp.Sexp)"><!-- --></A><H3>
removeNullElements</H3>
<PRE>
<A HREF="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A> <B>removeNullElements</B>(<A HREF="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</PRE>
<DL>
<DD>Removes all null elements, that is, those nodes of <code>tree</code> for
 which <A HREF="../../danbikel/parser/Treebank.html#isNullElementPreterminal(danbikel.lisp.Sexp)"><CODE>Treebank.isNullElementPreterminal(Sexp)</CODE></A> returns
 <code>true</code>.  Additionally, if the removal of a null element leaves
 an interior node that is childless, then this interior node is removed as
 well.  For example, if we have the following sentence in English
 <pre> (S (NP-SBJ (-NONE- *T*)) (VP ...)) </pre>
 it will be transformed to be
 <pre> (S (VP ...)) </pre>
 <b>N.B.</b>: This method should only be invoked <i>after</i> preprocessing
 with <A HREF="../../danbikel/parser/Training.html#relabelSubjectlessSentences(danbikel.lisp.Sexp)"><CODE>relabelSubjectlessSentences(Sexp)</CODE></A> and <A HREF="../../danbikel/parser/Training.html#addGapInformation(danbikel.lisp.Sexp)"><CODE>addGapInformation(Sexp)</CODE></A>, as these methods (and possibly others, if
 overridden) rely on the presence of null elements.
<P>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../danbikel/parser/Treebank.html#isNullElementPreterminal(danbikel.lisp.Sexp)"><CODE>Treebank.isNullElementPreterminal(Sexp)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="startSym()"><!-- --></A><H3>
startSym</H3>
<PRE>
<A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A> <B>startSym</B>()</PRE>
<DL>
<DD>Returns the symbol to indicate hidden nonterminals that precede the first
 in a sequence of modifier nonterminals.
<P>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../danbikel/parser/Trainer.html" title="class in danbikel.parser"><CODE>Trainer</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="startWord()"><!-- --></A><H3>
startWord</H3>
<PRE>
<A HREF="../../danbikel/parser/Word.html" title="class in danbikel.parser">Word</A> <B>startWord</B>()</PRE>
<DL>
<DD>Returns the <code>Word</code> object that represents the hidden "head
 word" of the start symbol.
<P>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../danbikel/parser/Training.html#startSym()"><CODE>startSym()</CODE></A>, 
<A HREF="../../danbikel/parser/Trainer.html" title="class in danbikel.parser"><CODE>Trainer</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="stopSym()"><!-- --></A><H3>
stopSym</H3>
<PRE>
<A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A> <B>stopSym</B>()</PRE>
<DL>
<DD>Returns the symbol to indicate a hidden nonterminal that follows the last
 in a sequence of modifier nonterminals.
 <p>
 This symbol may also be used as a special value that is guaranteed not
 to conflict with any nonterminal in a given language's treebank.
 <p>
<P>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../danbikel/parser/Trainer.html" title="class in danbikel.parser"><CODE>Trainer</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="stopWord()"><!-- --></A><H3>
stopWord</H3>
<PRE>
<A HREF="../../danbikel/parser/Word.html" title="class in danbikel.parser">Word</A> <B>stopWord</B>()</PRE>
<DL>
<DD>Returns the <code>Word</code> object that represents the hidden "head
 word" of the stop symbol.
<P>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../danbikel/parser/Training.html#stopSym()"><CODE>stopSym()</CODE></A>, 
<A HREF="../../danbikel/parser/Trainer.html" title="class in danbikel.parser"><CODE>Trainer</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="topSym()"><!-- --></A><H3>
topSym</H3>
<PRE>
<A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A> <B>topSym</B>()</PRE>
<DL>
<DD>Returns the symbol to indicate the hidden root of all parse trees.
<P>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../danbikel/parser/Trainer.html" title="class in danbikel.parser"><CODE>Trainer</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="topWord()"><!-- --></A><H3>
topWord</H3>
<PRE>
<A HREF="../../danbikel/parser/Word.html" title="class in danbikel.parser">Word</A> <B>topWord</B>()</PRE>
<DL>
<DD>Returns the <code>Word</code> object that represents the hidden "head
 word" of the hidden root of all parse trees.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="argNonterminals()"><!-- --></A><H3>
argNonterminals</H3>
<PRE>
<A HREF="http://java.sun.com/javase/6/docs/api/java/util/Set.html?is-external=true" title="class or interface in java.util">Set</A> <B>argNonterminals</B>()</PRE>
<DL>
<DD>Returns a static set of possible argument nonterminals.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>a static set of possible argument nonterminals</DL>
</DD>
</DL>
<HR>

<A NAME="removeArgAugmentation(danbikel.lisp.Symbol)"><!-- --></A><H3>
removeArgAugmentation</H3>
<PRE>
<A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A> <B>removeArgAugmentation</B>(<A HREF="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</A>&nbsp;label)</PRE>
<DL>
<DD>Removes any argument augmentations from the specified nonterminal label.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>label</CODE> - the label whose argument augmentations are to be removed
<DT><B>Returns:</B><DD>a new label with no argument augmentations</DL>
</DD>
</DL>
<HR>

<A NAME="removeGapAugmentation(danbikel.lisp.Sexp)"><!-- --></A><H3>
removeGapAugmentation</H3>
<PRE>
<A HREF="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A> <B>removeGapAugmentation</B>(<A HREF="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;sexp)</PRE>
<DL>
<DD>If the specified S-expression is a list, this method modifies the
 list to contain only symbols without gap augmentations;
 otherwise, this method removes the gap augmentation (if one exists)
 in the specified symbol and returns that new symbol.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sexp</CODE> - a symbol or list of symbols from which to remvoe any
 gap augmentations
<DT><B>Returns:</B><DD>a symbol or list of symbols with no gap augmentations</DL>
</DD>
</DL>
<HR>

<A NAME="postProcess(danbikel.lisp.Sexp)"><!-- --></A><H3>
postProcess</H3>
<PRE>
void <B>postProcess</B>(<A HREF="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</A>&nbsp;tree)</PRE>
<DL>
<DD>Post-processes a parse tree after decoding, eseentially undoing
 the steps performed in <A HREF="../../danbikel/parser/Training.html#preProcess(danbikel.lisp.Sexp)">preprocessing</A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>tree</CODE> - the tree to be post-processed</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Training.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
Parsing Engine</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../danbikel/parser/TrainerEvent.html" title="interface in danbikel.parser"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../danbikel/parser/Transition.html" title="class in danbikel.parser"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?danbikel/parser/Training.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Training.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
Author: <a href="http://www.cis.upenn.edu/~dbikel/">Dan Bikel.</a>
</BODY>
</HTML>
